<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Singly Linked List Stack]]></title>
    <url>%2F2020%2F06%2F23%2FSingly-Linked-List-Stack%2F</url>
    <content type="text"><![CDATA[Singly Linked List Stack 123456789101112131415161718192021222324252627282930313233343536373839private Node head = new Node(0);public void push(int num) &#123; Node node = new Node(num); Node temp = head; while(temp.next != null) &#123; temp = temp.next; &#125; temp.next = node;&#125;public int pop() &#123; if(head.next == null) &#123; throw new RuntimeException("棧空"); &#125; Node temp = head; while(temp.next.next != null) &#123; temp = temp.next; &#125; int val = temp.next.num; temp.next = null; return val;&#125;public void list() &#123; if(head.next == null) &#123; System.out.println("棧空"); return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node temp = head.next; while(temp != null) &#123; stack.push(temp); temp = temp.next; &#125; while(stack.size() &gt; 0) &#123; System.out.println(stack.pop()); &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array Stack]]></title>
    <url>%2F2020%2F06%2F23%2FArray-Stack%2F</url>
    <content type="text"><![CDATA[Array Stack 12345678910111213141516171819202122232425262728293031323334353637private int maxSize;private int[] stack;private int top = -1;public ArrayStack(int maxSize) &#123; this.maxSize = maxSize; stack = new int[this.maxSize];&#125;public void push(int num) &#123; if(isFull()) &#123; System.out.println("棧滿"); return; &#125; top++; stack[top] = num;&#125;public int pop() &#123; if(isEmpty()) &#123; throw new RuntimeException("棧空"); &#125; int temp = stack[top]; top--; return temp;&#125;public void list() &#123; if(isEmpty()) &#123; System.out.println("棧空"); return; &#125; //從棧頂開始顯示數據 for (int i = top; i &gt;= 0 ; i--) &#123; System.out.printf("stack[%d]=%d\n", i, stack[i]); &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Josephus Problem]]></title>
    <url>%2F2020%2F06%2F21%2FJosephus-Problem%2F</url>
    <content type="text"><![CDATA[Josephus Problem 123456789101112131415161718192021222324252627282930313233343536373839/*start: 從第幾個node開始數數count: 數幾下num: 最初總共有幾個node*/public void count(int start, int count, int num) &#123; if(head == null || start &lt; 1 || count &lt; 1 || start &gt; num) &#123; System.out.println("參數輸入有誤，請重新輸入"); return; &#125; Node helper = head; while(true) &#123; if(helper.getNext() == head) &#123; //helper指向最後一個節點 break; &#125; helper = helper.getNext(); &#125; //報數前，先讓head和helper移動 start - 1 次 for (int i = 0; i &lt; start - 1; i++) &#123; head = head.getNext(); helper = helper.getNext(); &#125; //報數時，讓head和helper移動 count -1 次，然後出圈 //這裡是一個循環操作，直到圈中剩下一個節點 while(true) &#123; if(helper == head) &#123; break; &#125; for (int i = 0; i &lt; count - 1; i++) &#123; head = head.getNext(); helper = helper.getNext(); &#125; //這時head指向要出圈的節點 System.out.printf("節點編號%d出圈\n", head.getNo()); head = head.getNext(); helper.setNext(head); &#125; System.out.println("最後留在圈中的節點編號是" + helper.getNo());&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doubly Linked List]]></title>
    <url>%2F2020%2F06%2F21%2FDoubly-Linked-List%2F</url>
    <content type="text"><![CDATA[Doubly Linked List 1234567891011121314151617181920212223242526272829303132public void addNodeByOrder(HeroNode node) &#123; //因為頭節點不能動，我們需要通過輔助指針(變量)來找到添加的位置 //我們找的temp是位於添加位置的前一個節點 HeroNode temp = head; boolean flag = false; //標識添加的編號是否存在 while(true) &#123; if(temp.next == null) &#123; break; &#125; if(temp.next.no &gt; node.no) &#123; break; &#125; else if (temp.next.no == node.no) &#123; flag = true; break; &#125; temp = temp.next; &#125; //退出while loop if(flag) &#123; System.out.printf("準備加入的英雄的編號 %d 已經存在，不能加入\n", node.no); &#125; else &#123; if(temp.next == null) &#123; node.prev = temp; temp.next = node; &#125; else &#123; node.prev = temp; node.next = temp.next; temp.next.prev = node; temp.next = node; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Singly Linked List Interview Question]]></title>
    <url>%2F2020%2F06%2F20%2FSingly-Linked-List-Interview-Question%2F</url>
    <content type="text"><![CDATA[Singly Linked List Interview Question 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//獲取Linked list中節點的個數，不統計頭節點public static int getLength(HeroNode head) &#123; if(head.next == null) &#123; return 0; &#125; int length = 0; HeroNode temp = head.next; while(temp != null) &#123; length++; temp = temp.next; &#125; return length;&#125;//獲取Linked list中倒數第k個節點public static HeroNode getLastIndexNode(HeroNode head, int index) &#123; if(head.next == null) &#123; return null; &#125; int length = getLength(head); if(index &lt;=0 || index &gt; length) &#123; return null; &#125; HeroNode temp = head.next; for (int i = 0; i &lt; length - index; i++) &#123; temp = temp.next; &#125; return temp;&#125;//反轉Linked listpublic static void reverseList(HeroNode head) &#123; if(head.next == null || head.next.next == null) &#123; return; &#125; HeroNode cur = head.next; HeroNode next = null; HeroNode reverseHead = new HeroNode(0,"",""); while(cur != null) &#123; next = cur.next; //利用next保存下一個節點 cur.next = reverseHead.next; //將cur的下一個節點指向新Linked list的最前端 reverseHead.next = cur; //將當前節點cur連接到新Linked list cur = next; //cur後移 &#125; head.next = reverseHead.next;&#125;//逆序打印Linked listpublic static void reversePrint(HeroNode head) &#123; if(head.next == null) &#123; return; &#125; Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;(); HeroNode temp = head.next; while(temp != null) &#123; stack.push(temp); temp = temp.next; &#125; while(stack.size() &gt; 0) &#123; System.out.println(stack.pop()); &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Singly Linked List]]></title>
    <url>%2F2020%2F06%2F20%2FSingly-Linked-List%2F</url>
    <content type="text"><![CDATA[Singly Linked List 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//初始化一個頭節點，頭節點不要動，不存放具體數據private HeroNode head = new HeroNode(0,"","");//添加節點到Linked List//不考慮編號順序public void addNode(HeroNode node) &#123; HeroNode temp = head; //遍歷Linked List，找到最後一個節點 while(true) &#123; if(temp.next == null) &#123; break; &#125; temp = temp.next; &#125; //當退出while loop時，temp指向了Linked List最後一個節點 temp.next = node;&#125;//根據編號將英雄插入到指定位置public void addNodeByOrder(HeroNode node) &#123; //因為頭節點不能動，我們需要通過輔助指針(變量)來找到添加的位置 //我們找的temp是位於添加位置的前一個節點，否則加入不了 HeroNode temp = head; boolean flag = false; //標識添加的編號是否存在 while(true) &#123; if(temp.next == null) &#123; break; &#125; if(temp.next.no &gt; node.no) &#123; break; &#125; else if (temp.next.no == node.no) &#123; flag = true; break; &#125; temp = temp.next; &#125; //退出while loop if(flag) &#123; System.out.printf("準備加入的英雄的編號 %d 已經存在，不能加入\n", node.no); &#125; else &#123; node.next = temp.next; temp.next = node; &#125;&#125;public void updateNode(HeroNode node) &#123; if(head.next == null) &#123; System.out.println("Linked list is empty."); return; &#125; HeroNode temp = head.next; boolean flag = false; //標識是否找到準備編輯的英雄的編號 while(true) &#123; if(temp == null) &#123; break; &#125; if(temp.no == node.no) &#123; flag = true; break; &#125; temp = temp.next; &#125; if(flag) &#123; temp.name = node.name; temp.nickname = node.nickname; &#125; else &#123; System.out.printf("Cannot find hero with no=%d\n", node.no); &#125;&#125;public void deleteNode(int no) &#123; if(head.next == null) &#123; System.out.println("Linked list is empty."); return; &#125; HeroNode temp = head; boolean flag = false; while(true) &#123; if(temp.next == null) &#123; break; &#125; if(temp.next.no == no) &#123; flag = true; break; &#125; temp = temp.next; &#125; if(flag) &#123; temp.next = temp.next.next; &#125; else &#123; System.out.printf("Cannot delete hero with no=%d\n", no); &#125;&#125; 總結： 什麼時候HeroNode temp = head，什麼時候HeroNode temp = head.next？ temp是一個指針，當你需要使用temp.next做事情，例如deleteNode()當中，temp需要指向head 123if(flag) &#123; temp.next = temp.next.next;&#125; 如果你需要使用temp做事情，temp可以指向head.next，例如updateNode()當中 1234if(flag) &#123; temp.name = node.name; temp.nickname = node.nickname;&#125; temp一開始指向哪裡，視乎你的解題思路，視乎你後面要做什麼。 Singly linked list的缺點 查找的方向只能是一個方向，向後查找，Doubly linked list可以向前或向後查找。 Singly linked list不能自我刪除，需要靠輔助節點，總是通過temp，temp是待刪除節點的前一個節點；而Doubly linked list則可以自我刪除。]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Circular Array Queue]]></title>
    <url>%2F2020%2F06%2F16%2FCircular-Array-Queue%2F</url>
    <content type="text"><![CDATA[Circular Array Queue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private int maxSize;private int front; //指向隊列第一個元素，初始值是0private int rear; //指向隊列最後一個元素的後一個位置，初始值是0，arr[rear]總是一個空白位置private int[] arr;public boolean isFull() &#123; // 假設maxSize=4，當rear=3，front=0，隊列已滿 // 假設maxSize=4，當rear=0，front=1，隊列已滿 return (rear + 1) % maxSize == front;&#125;public boolean isEmpty() &#123; return front == rear;&#125;public void addToQueue(int num) &#123; if(isFull()) &#123; System.out.println("The queue is full, cannot add data."); return; &#125; arr[rear] = num; rear = (rear + 1) % maxSize;&#125;public int getFrmQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException("The queue is empty, cannot retrieve data."); &#125; int value = arr[front]; front = (front + 1) % maxSize; return value;&#125;public void showQueue() &#123; if(isEmpty()) &#123; System.out.println("The queue is empty, there are no data."); return; &#125; for (int i = front; i &lt; front + size(); i++) &#123; System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]); &#125;&#125;public int peekQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException("The queue is empty, there are no data."); &#125; return arr[front];&#125;//求得當前有效數據的個數public int size() &#123; // 假設maxSize=4，rear=1，front=0，有效數據1個 // 假設maxSize=4，rear=3，front=1，有效數據2個 return (rear + maxSize - front) % maxSize;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array Queue]]></title>
    <url>%2F2020%2F06%2F15%2FArray-Queue%2F</url>
    <content type="text"><![CDATA[Array Queue 1234567891011121314public ArrayQueue(int maxSize) &#123; this.maxSize = maxSize; arr = new int[maxSize]; front = -1; //指向隊列頭一個數據的前一個位置 rear = -1; //指向隊列最後一個數據&#125;public boolean isFull() &#123; return rear == maxSize - 1;&#125;public boolean isEmpty() &#123; return front == rear;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sparse Array]]></title>
    <url>%2F2020%2F06%2F14%2FSparse-Array%2F</url>
    <content type="text"><![CDATA[Sparse Array 稀疏數組 123456789101112131415161718192021222324252627//遍歷chessArr，取得有效數據個數sumint sum = 0;for(int i=0; i&lt;chessArr.length; i++) &#123; for(int j=0; j&lt;chessArr[0].length; j++) &#123; if(chessArr[i][j] != null) &#123; sum++; &#125; &#125;&#125;Integer[][] sparseArr = new Integer[sum+1][3];sparseArr[0][0] = chessArr.length;sparseArr[0][1] = chessArr[0].length;sparseArr[0][2] = sum;//count代表當前發現的有效數據個數int count = 0;for(int i=0; i&lt;chessArr.length; i++) &#123; for(int j=0; j&lt;chessArr[0].length; j++) &#123; if(chessArr[i][j] != null) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr[i][j]; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[測 試 Test]]></title>
    <url>%2F2020%2F06%2F10%2F%E6%B8%AC%20%E8%A9%A6%2F</url>
    <content type="text"><![CDATA[Testingcontent content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content Somethingcontent content content content content content content content content content content content content content content content content content content content content content Section 2content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content content End]]></content>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贏在起跑線]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%B4%8F%E5%9C%A8%E8%B5%B7%E8%B7%91%E7%B7%9A%2F</url>
    <content type="text"><![CDATA[年紀漸長，越來越發現練習的重要性，越發覺得缺乏時間精進自己喜歡的技能。如果您尚年輕，在此非常鼓勵您發掘自己的興趣，趁年少的時候學習自己喜歡的事情，學語文、玩樂器、玩運動等都可以。 每項技能需要很長的時間沉浸，才會熟練，而年青的時候，是經濟負擔最小，煩惱比較少(和小)，私人時間最多的時候，在這個人生階段，您可以投放於練習的時間和心力都比較多。”少壯不努力，老大徒傷悲”這句話背後是千真萬確的生活體驗，年少也許聽不懂老人的道理，甚至嫌嘮叨不想聽，可以理解，那爲什麼還說呢?因爲覺得該勸的還是得勸一勸，萬一聽進去了，可以造福一個年輕的生命，很值得！ 從年青人生理和心理條件之於學習的優勢而言，不難理解爲什麼今日社會很多父母把孩童送到各種興趣班，當然朋輩壓力也是原因之一，說的是父母承受的朋輩壓力…眼看着別家孩子學英語、鋼琴、芭蕾，自家孩子還呆在家裏玩玩具，父母深怕孩子輸在起跑線，終於開始給他/她各種報名。 個人認爲趁年輕給予孩子探索興趣的機會，很值得鼓勵，只是父母心態上過於功利，給孩子太多壓力，對孩子的身、心、技能發展，會造成哪些影響呢？是不是真的能讓孩子贏在起跑線上呢？筆者保留一個問號。]]></content>
      <tags>
        <tag>隨筆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Why Blogging?]]></title>
    <url>%2F2018%2F03%2F31%2FWhy%20Blogging%2F</url>
    <content type="text"><![CDATA[折騰了一陣子，各種爬文如何安裝Hexo、設置主題，終於來到使用Markdown寫文章這一步，有點小小的成就感。希望通過這個平臺，分享一些所見所想，也練練文筆。 在這個社交平臺活躍的時代，我們更多去接收外界的消息，消化後給出簡短的評價，甚至只是動動手指頭給個讚，坐下來寫文章顯得很奢侈。它很需要功夫，功夫有兩個含義，時間和技巧。我們要花時間梳理自己的思緒，發展成觀點，透過文字傳達給讀者。遣詞造句、恰當舉例、觀點的先後輕重鋪排等各種技巧，都會影響讀者的吸收。如果我們太習慣社交平臺的速食文化，缺少這些功夫的鍛煉，也許會令我們不懂表達自己那些深層的想法，進一步說，可能我們深層的社交需要變得難以發展和被滿足。因爲人們不習慣於對我有更詳盡的評價，我也不善於對別人作出那樣的評價，可能我們都太活躍於那種Hi-Like-Bye式交流，即使面對我們的親友。無論如何，希望這裏的文章能帶給您一點點啓發，一點點共鳴，或者一點點放鬆。]]></content>
      <tags>
        <tag>隨筆</tag>
      </tags>
  </entry>
</search>
